let DEFAULT_SETTINGS = {
    autoUpdate: true,
    scriptLimit: 13,
    injectionTiming: "document_start",
    debugMode: false,
    metadataPreference: "zedata"
};

let elements = {
    autoUpdate: document.getElementById("auto-update"),
    scriptLimit: document.getElementById("script-limit"),
    injectionTiming: document.getElementById("injection-timing"),
    debugMode: document.getElementById("debug-mode"),
    metadataPreference: document.getElementById("metadata-preference"),
    exportAll: document.getElementById("export-all"),
    importAll: document.getElementById("import-all"),
    clearAll: document.getElementById("clear-all"),
    saveSettings: document.getElementById("save-settings"),
    statusMessage: document.getElementById("status-message")
};

async function loadSettings() {
    chrome.storage.sync.get("settings", e => {
        e = e.settings || DEFAULT_SETTINGS;
        elements.autoUpdate.checked = e.autoUpdate;
        elements.scriptLimit.value = e.scriptLimit;
        elements.injectionTiming.value = e.injectionTiming;
        elements.debugMode.checked = e.debugMode;
        elements.metadataPreference.value = e.metadataPreference;
    });
}

async function saveSettings() {
    var e = {
        autoUpdate: elements.autoUpdate.checked,
        scriptLimit: parseInt(elements.scriptLimit.value, 10),
        injectionTiming: elements.injectionTiming.value,
        debugMode: elements.debugMode.checked,
        metadataPreference: elements.metadataPreference.value
    };
    if (e.scriptLimit < 1 || 100 < e.scriptLimit) {
        showStatus("Script size limit must be between 1 and 100 KB", "error");
    } else {
        chrome.storage.sync.set({
            settings: e
        }, () => {
            showStatus("Settings saved successfully", "success");
        });
    }
}

async function exportAllScripts() {
    chrome.runtime.sendMessage({
        action: "getScripts"
    }, e => {
        var t, s, e = e.scripts || [];
        if (0 === e.length) {
            showStatus("No scripts to export", "error");
        } else {
            t = new Blob([JSON.stringify(e, null, 2)], {
                type: "application/json"
            });
            t = URL.createObjectURL(t);
            (s = document.createElement("a")).href = t;
            s.download = `zedmonkey-scripts-${(new Date).toISOString().slice(0,10)}.json`;
            s.click();
            URL.revokeObjectURL(t);
            showStatus(`Exported ${e.length} scripts`, "success");
        }
    });
}

async function importAllScripts() {
    var e = document.createElement("input");
    e.type = "file";
    e.accept = ".json";
    e.onchange = e => {
        var t, e = e.target.files[0];
        if (e) {
            (t = new FileReader).onload = e => {
                try {
                    var t = JSON.parse(e.target.result);
                    if (!Array.isArray(t)) throw new Error("Invalid format: expected an array of scripts");
                    chrome.runtime.sendMessage({
                        action: "importScripts",
                        scripts: t
                    }, e => {
                        if (e.success) {
                            showStatus(`Imported ${e.count} scripts`, "success");
                        } else {
                            showStatus("Error importing scripts: " + e.error, "error");
                        }
                    });
                } catch (e) {
                    showStatus("Error parsing file: " + e.message, "error");
                }
            };
            t.readAsText(e);
        }
    };
    e.click();
}

async function clearAllScripts() {
    if (confirm("Are you sure you want to delete ALL scripts? This cannot be undone.")) {
        chrome.runtime.sendMessage({
            action: "clearAllScripts"
        }, e => {
            if (e.success) {
                showStatus("All scripts have been deleted", "success");
            } else {
                showStatus("Error clearing scripts: " + e.error, "error");
            }
        });
    }
}

function showStatus(e, t = "success") {
    elements.statusMessage.textContent = e;
    elements.statusMessage.className = "status-message " + t;
    setTimeout(() => {
        elements.statusMessage.textContent = "";
        elements.statusMessage.className = "status-message";
    }, 3e3);
}

document.addEventListener("DOMContentLoaded", loadSettings);
elements.saveSettings.addEventListener("click", saveSettings);
elements.exportAll.addEventListener("click", exportAllScripts);
elements.importAll.addEventListener("click", importAllScripts);
elements.clearAll.addEventListener("click", clearAllScripts);