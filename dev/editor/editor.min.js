let jsGrammar = [];

// Fix the loadGrammarRules function to handle the non-module grammar.js
function loadGrammarRules() {
    fetch('grammar.js')
        .then(response => response.text())
        .then(text => {
            try {
                // Look for the grammar array in the non-module format
                const grammarText = text.match(/const jsGrammar = (\[[\s\S]*?\]);/);
                if (grammarText && grammarText[1]) {
                    // Instead of trying to parse as JSON, evaluate it safely
                    eval(text);
                    
                    // Apply highlighting if editor is already loaded
                    if (document.getElementById("script-content")) {
                        highlightSyntax();
                    }
                } else {
                    console.error("Grammar definition not found in grammar.js");
                    setupFallbackGrammar();
                }
            } catch (e) {
                console.error("Error parsing grammar:", e);
                setupFallbackGrammar();
            }
        })
        .catch(error => {
            console.error("Error loading grammar:", error);
            setupFallbackGrammar();
        });
}

// Add the missing highlightMatchingBrackets function
function highlightMatchingBrackets(text, position) {
    if (!text || position === undefined) return;
    
    const brackets = {
        '(': ')',
        '{': '}',
        '[': ']'
    };
    
    const closingBrackets = {
        ')': '(',
        '}': '{',
        ']': '['
    };
    
    // Check if cursor is on a bracket
    const char = text[position];
    const prevChar = position > 0 ? text[position - 1] : null;
    
    let matchPos = -1;
    let startBracket, endBracket;
    
    // Check if cursor is right after an opening bracket
    if (prevChar && brackets[prevChar]) {
        startBracket = prevChar;
        endBracket = brackets[prevChar];
        
        // Find matching closing bracket
        let depth = 1;
        for (let i = position; i < text.length; i++) {
            if (text[i] === startBracket) {
                depth++;
            } else if (text[i] === endBracket) {
                depth--;
                if (depth === 0) {
                    matchPos = i;
                    break;
                }
            }
        }
    }
    // Check if cursor is on a closing bracket
    else if (char && closingBrackets[char]) {
        endBracket = char;
        startBracket = closingBrackets[char];
        
        // Find matching opening bracket
        let depth = 1;
        for (let i = position - 1; i >= 0; i--) {
            if (text[i] === endBracket) {
                depth++;
            } else if (text[i] === startBracket) {
                depth--;
                if (depth === 0) {
                    matchPos = i;
                    break;
                }
            }
        }
    }
    
    // Highlight matching brackets if found
    if (matchPos !== -1) {
        // For now, just log the match - we'll implement visual highlighting later
        console.log("Matching brackets found at positions:", position, "and", matchPos);
        
        // You could add visual highlighting here by manipulating the DOM
        // This would require more complex code to insert spans at specific positions
    }
}

// Setup fallback grammar in case loading fails
function setupFallbackGrammar() {
    jsGrammar = [
        { name: 'comment', pattern: new RegExp('\/\/.*|\/\\*[\\s\\S]*?\\*\/', 'y') },
        { name: 'string', pattern: new RegExp('"(?:\\\\.|[^"\\\\])*"|\'(?:\\\\.|[^\'\\\\])*\'|`(?:\\\\.|[^`\\\\])*`', 'y') },
        { name: 'number', pattern: new RegExp('\\b\\d+(\\.\\d+)?\\b', 'y') },
        { name: 'keyword', pattern: new RegExp('\\b(?:function|const|let|var|if|else|for|while|return)\\b', 'y') },
        { name: 'boolean', pattern: new RegExp('\\b(?:true|false)\\b', 'y') },
        { name: 'operator', pattern: new RegExp('[=+\\-*/%<>!&|~^?:]+', 'y') },
        { name: 'punctuation', pattern: new RegExp('[{}\\[\\]();,.]', 'y') },
        { name: 'identifier', pattern: new RegExp('[a-zA-Z_$][a-zA-Z0-9_$]*', 'y') }
    ];
    
    // Apply highlighting if editor is already loaded
    if (document.getElementById("script-content")) {
        highlightSyntax();
    }
}

// Call this at the beginning of your script
loadGrammarRules();

let urlParams = new URLSearchParams(window.location.search),
    scriptId = urlParams.get("id"),
    scriptName = urlParams.get("name") || "New Script",
    domElements = {};

function getElement(e) {
    return domElements[e] || (domElements[e] = document.getElementById(e)), domElements[e]
}

function deleteScript() {
    scriptId ? confirm("Are you sure you want to delete this script?") && chrome.runtime.sendMessage({
        action: "removeScript",
        scriptId: scriptId
    }, e => {
        e && e.success ? (showStatusMessage("Script deleted"), setTimeout(() => {
            window.location.href = "editor.html"
        }, 1e3)) : showStatusMessage("Error deleting script", !0)
    }) : showStatusMessage("Cannot delete new script", !0)
}

function applyHighlighting(text) {
    if (!text) return "";
    
    // Escape HTML to prevent injection
    text = text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;');
    
    const lines = text.split('\n');
    const highlightedLines = [];
    
    // Process each line separately
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const tokens = tokenizeLine(line);
        highlightedLines.push(renderLineTokens(tokens));
    }
    
    return highlightedLines.join('\n');
}

// Tokenize a single line using the grammar rules
function tokenizeLine(line) {
    const tokens = [];
    let lastIndex = 0;
    
    // Special handling for UserScript metadata section
    if (line.includes('// ==UserScript==') || line.includes('// ==/UserScript==')) {
        tokens.push({ type: 'meta-section', text: line });
        return tokens;
    }
    
    // Special handling for UserScript metadata tags
    if (line.match(/\/\/ @\w+/)) {
        const parts = line.match(/^(\/\/ @\w+)(\s+)(.+?)$/);
        if (parts) {
            tokens.push({ type: 'meta', text: parts[1] });
            tokens.push({ type: 'plain', text: parts[2] });
            tokens.push({ type: 'string', text: parts[3] });
            return tokens;
        }
    }
    
    // Process the line with grammar rules
    while (lastIndex < line.length) {
        let matched = false;
        
        for (const rule of jsGrammar) {
            rule.pattern.lastIndex = lastIndex;
            const match = rule.pattern.exec(line);
            
            if (match && match.index === lastIndex) {
                tokens.push({ type: rule.name, text: match[0] });
                lastIndex += match[0].length;
                matched = true;
                break;
            }
        }
        
        // If no rule matched, consume one character
        if (!matched) {
            tokens.push({ type: 'plain', text: line[lastIndex] });
            lastIndex++;
        }
    }
    
    return tokens;
}

// Render tokens to HTML
function renderLineTokens(tokens) {
    return tokens.map(token => 
        `<span class="token ${token.type}">${token.text}</span>`
    ).join('');
}

// Update the highlightSyntax function to properly apply the highlighting
function highlightSyntax() {
    const editor = document.getElementById("script-content");
    const highlightLayer = document.getElementById("highlight-layer");
    
    if (!editor || !highlightLayer) return;
    
    // Use requestAnimationFrame for better performance
    requestAnimationFrame(() => {
        // Apply syntax highlighting
        const highlighted = applyHighlighting(editor.value);
        highlightLayer.innerHTML = highlighted;
        
        // Ensure the highlight layer has the same dimensions and scroll position
        highlightLayer.scrollTop = editor.scrollTop;
        highlightLayer.scrollLeft = editor.scrollLeft;
        
        // Highlight matching brackets
        highlightMatchingBrackets(editor.value, editor.selectionStart);
    });
}


function applyHighlighting(e) {
    return e ? e
        // Comentarios
        .replace(/(\/\/.*$)/gm, '<span class="token comment">$1</span>')
        .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="token comment">$1</span>')
        
        // Strings y templates
        .replace(/("(?:\\.|[^"\\])*")|('(?:\\.|[^'\\])*')|(`(?:\\.|[^`\\])*`)/g, '<span class="token string">$&</span>')
        
        // Números
        .replace(/\b(-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/g, '<span class="token number">$1</span>')
        
        // Palabras clave
        .replace(/\b(function|const|let|var|return|if|else|for|while|do|switch|case|break|continue|new|try|catch|finally|throw|class|extends|import|export|default|from|async|await|this|super|yield|typeof|instanceof|in|of|delete|void|null|undefined|true|false)\b/g, '<span class="token keyword">$1</span>')
        
        // Funciones (declaraciones y llamadas)
        .replace(/(\b\w+\b)(?=\s*\()/g, '<span class="token function">$1</span>')
        
        // Objetos y propiedades
        .replace(/(\w+)\.(\w+)/g, '<span class="token object">$1</span><span class="token punctuation">.</span><span class="token property">$2</span>')
        
        // Parámetros de función
        .replace(/(function\s+\w+)\s*\(([^)]*)\)/g, (match, p1, p2) => 
            `${p1}<span class="token punctuation">(</span>${p2.replace(/(\w+)/g, '<span class="token parameter">$1</span>')}<span class="token punctuation">)</span>`
        )
        
        // Operadores
        .replace(/(\+|\-|\*|\/|%|=|==|===|!=|!==|>|<|>=|<=|&&|\|\||!|\?|:|&|\||\^|~|<<|>>|>>>|\+=|-=|\*=|\/=|%=)/g, '<span class="token operator">$1</span>')
        
        // Símbolos especiales
        .replace(/([{}[\]()<>.,;:])/g, '<span class="token punctuation">$1</span>')
        
        // Variables y constantes
        .replace(/\b([A-Z_][A-Z0-9_]+)\b/g, '<span class="token constant">$1</span>')
        : "";
}

function updateCursorPosition() {
    let e = document.getElementById("script-content"),
        t = document.getElementById("cursor-position"),
        n = e.value,
        s = e.selectionStart,
        o = 1,
        i = 1;
    for (let e = 0; e < s; e++) "\n" === n[e] ? (o++, i = 1) : i++;
    t.textContent = `Line: ${o}, Column: ` + i, highlightCurrentLine(o)
}

function highlightCurrentLine(e) {
    var t = document.getElementById("highlight-layer"),
        n = t.innerHTML.split("\n");
    for (let e = 0; e < n.length; e++) n[e] = n[e].replace(/<div class="current-line">(.*?)<\/div>/g, "$1");
    0 < e && e <= n.length && (n[e - 1] = `<div class="current-line">${n[e-1]}</div>`), t.innerHTML = n.join("\n")
}

function loadTempContentIfNeeded() {
    "true" === new URLSearchParams(window.location.search).get("loadTemp") && chrome.storage.local.get("tempScriptContent", e => {
        e.tempScriptContent ? (editor.setValue(e.tempScriptContent), chrome.storage.local.remove("tempScriptContent")) : console.error("No temporary script content found")
    })
}

let highlightTimeout;

function initializeEditor() {
    let scriptContent = document.getElementById("script-content");
    let highlightLayer = document.getElementById("highlight-layer");
    
    // Make sure the highlight layer exists
    if (!highlightLayer) {
        console.error("Highlight layer not found!");
        return;
    }
    
    document.getElementById("save-script").addEventListener("click", saveScript);
    document.getElementById("cancel-edit").addEventListener("click", cancelEdit);
    
    // Add event listeners for action buttons if they exist
    let actionButton = document.getElementById("download-script");
    actionButton && actionButton.addEventListener("click", downloadScript);
    
    actionButton = document.getElementById("refresh-script");
    actionButton && actionButton.addEventListener("click", refreshScript);
    
    actionButton = document.getElementById("delete-script");
    actionButton && actionButton.addEventListener("click", deleteScript);
    
    actionButton = document.getElementById("log-button");
    actionButton && actionButton.addEventListener("click", logScriptContent);
    
    // Apply syntax highlighting with debounce based on content size
    scriptContent.addEventListener("input", () => {
        clearTimeout(highlightTimeout);
        updateLineNumbers();
        updateCursorPosition();
        
        // For small files, highlight immediately
        if (scriptContent.value.length < 10000) {
            highlightSyntax();
        } else {
            // For larger files, debounce to avoid performance issues
            highlightTimeout = setTimeout(highlightSyntax, 200);
        }
    });
    
    // Ensure scroll synchronization between content and highlight layer
    scriptContent.addEventListener("scroll", () => {
        syncScroll();
        highlightLayer.scrollTop = scriptContent.scrollTop;
        highlightLayer.scrollLeft = scriptContent.scrollLeft;
    });
    
    // Add editor interaction event listeners
    scriptContent.addEventListener("keydown", handleTabKey);
    scriptContent.addEventListener("click", updateCursorPosition);
    scriptContent.addEventListener("keyup", updateCursorPosition);
    
    // Initialize search functionality
    document.getElementById("search-scripts").addEventListener("input", filterScripts);
    
    // Load scripts and initialize content
    loadAllScripts();
    
    if (scriptId) {
        loadScriptContent(scriptId);
    } else {
        scriptContent.value = getScriptTemplate();
        updateLineNumbers();
        highlightSyntax();
    }
    
    // Handle temporary content loading if needed
    if (urlParams.get("loadTemp")) {
        chrome.storage.local.get("tempScriptContent", function(data) {
            if (data.tempScriptContent) {
                scriptContent.value = data.tempScriptContent;
                updateLineNumbers();
                highlightSyntax();
                chrome.storage.local.remove("tempScriptContent");
            }
        });
    }
}

function getScriptTemplate() {
    return `// [script]
// name:Hello World Script,
// namespace:zedmonkey,
// version:1.0.0,
// description:Hello World!,
// match:*://*/*,
// grant:,

(function() {
    'use strict';
    
})();
`
}

function loadAllScripts() {
    chrome.runtime.sendMessage({
        action: "getScripts"
    }, e => {
        e && e.scripts ? renderScriptsList(e.scripts) : showStatusMessage("Error loading scripts", !0)
    })
}

function renderScriptsList(e) {
    let a = document.getElementById("scripts-list");
    a.innerHTML = "", 0 === e.length ? a.innerHTML = '<div class="empty-state">No scripts installed</div>' : e.forEach(e => {
        var t = document.createElement("div"),
            n = (t.className = "script-item", e.id === scriptId && t.classList.add("active"), getScriptType(e)),
            s = (t.style.borderLeftColor = "css" === n ? "#4caf50" : "bookmarklet" === n ? "#2196f3" : "#ffcc00", document.createElement("div")),
            o = (s.className = "script-info", document.createElement("div")),
            i = (o.style.display = "flex", o.style.alignItems = "center", document.createElement("span"));
        i.className = "script-badge " + n, i.textContent = n.toUpperCase(), o.appendChild(i), (n = document.createElement("div")).className = "script-name", n.style.display = "inline", n.textContent = e.metadata?.name || "Unnamed Script", o.appendChild(n), s.appendChild(o), (i = document.createElement("div")).className = "script-meta", i.textContent = `v${e.metadata?.version||"1.0"} • ` + (e.metadata?.match?.[0] || "*"), s.appendChild(i), e.metadata?.description && ((n = document.createElement("div")).className = "script-description", n.textContent = e.metadata.description, s.appendChild(n)), (o = document.createElement("label")).className = "toggle-switch", (i = document.createElement("input")).type = "checkbox", i.checked = !1 !== e.enabled, i.dataset.scriptId = e.id, i.addEventListener("change", toggleScriptEnabled), (n = document.createElement("span")).className = "slider", o.appendChild(i), o.appendChild(n), t.appendChild(s), t.appendChild(o), s.addEventListener("click", () => {
            window.location.href = `editor.html?id=${e.id}&name=` + encodeURIComponent(e.metadata?.name || "Script")
        }), a.appendChild(t)
    })
}

function getScriptType(e) {
    if (e.content) {
        if (e.metadata?.type) return e.metadata.type.toLowerCase();
        if (!e.content.includes("@resource") && !e.content.includes("@require")) {
            if (e.content.trim().startsWith("javascript:")) return "bookmarklet";
            e.content.includes("@-moz-document") || e.content.includes("@namespace") || e.content.includes("@media")
        }
    }
    return "js"
}

function toggleScriptEnabled(t) {
    let e = t.target.dataset.scriptId,
        n = t.target.checked;
    chrome.runtime.sendMessage({
        action: "toggleScriptEnabled",
        scriptId: e,
        enabled: n
    }, e => {
        e && e.success ? showStatusMessage("Script " + (n ? "enabled" : "disabled")) : (showStatusMessage("Error updating script state", !0), t.target.checked = !n)
    })
}

function filterScripts(e) {
    let s = e.target.value.toLowerCase();
    document.querySelectorAll(".script-item").forEach(e => {
        var t = e.querySelector(".script-name").textContent.toLowerCase(),
            n = e.querySelector(".script-meta").textContent.toLowerCase();
        t.includes(s) || n.includes(s) ? e.style.display = "flex" : e.style.display = "none"
    })
}

function loadScriptContent(e) {
    chrome.runtime.sendMessage({
        action: "getScriptContent",
        scriptId: e
    }, e => {
        e && e.content ? (document.getElementById("script-content").value = e.content, updateLineNumbers(), showStatusMessage("Script loaded successfully")) : showStatusMessage("Error loading script", !0)
    })
}

function saveScript() {
    var e, t = document.getElementById("script-content").value.trim();
    t ? (e = scriptId ? "updateScriptContent" : "addScript", chrome.runtime.sendMessage({
        action: e,
        scriptContent: t,
        scriptId: scriptId
    }, e => {
        e && e.success ? (showStatusMessage("Script saved successfully"), !scriptId && e.scriptId && (window.location.href = `editor.html?id=${e.scriptId}&name=` + encodeURIComponent(e.name || "Script"))) : showStatusMessage("Error saving script: " + (e.error || "Unknown error"), !0)
    })) : showStatusMessage("Please enter script content", !0)
}

function cancelEdit() {
    window.close()
}

function logScriptContent() {
    console.log(document.getElementById("script-content").value), showStatusMessage("Script content logged to console")
}

function updateLineNumbers() {
    var e = document.getElementById("script-content"),
        t = document.getElementById("line-numbers"),
        n = e.value.split("\n").length;
    t.innerHTML = "";
    for (let e = 1; e <= Math.max(10, n); e++) {
        var s = document.createElement("div");
        s.textContent = e, t.appendChild(s)
    }
}

function syncScroll() {
    var e = document.getElementById("script-content");
    document.getElementById("line-numbers").scrollTop = e.scrollTop
}

function handleTabKey(e) {
    var t, n;
    "Tab" === e.key && (e.preventDefault(), t = (e = e.target).selectionStart, n = e.selectionEnd, e.value = e.value.substring(0, t) + "  " + e.value.substring(n), e.selectionStart = e.selectionEnd = t + 2)
}

function showStatusMessage(e, t = !1) {
    let n = document.getElementById("status-message");
    n.textContent = e, n.style.color = t ? "#f44336" : "#4caf50", setTimeout(() => {
        n.textContent = ""
    }, 3e3)
}

function downloadScript() {
    var e = document.getElementById("script-content").value,
        t = document.getElementById("script-title").textContent.replace(/[^a-z0-9]/gi, "_").toLowerCase() + ".js",
        e = new Blob([e], {
            type: "text/javascript"
        });
    let n = URL.createObjectURL(e),
        s = document.createElement("a");
    s.href = n, s.download = t, document.body.appendChild(s), s.click(), setTimeout(() => {
        document.body.removeChild(s), URL.revokeObjectURL(n)
    }, 0), showStatusMessage("Script downloaded")
}

function refreshScript() {
    scriptId ? (loadScriptContent(scriptId), showStatusMessage("Script refreshed")) : showStatusMessage("Cannot refresh new script", !0)
}
// Add these functions to the existing JavaScript file

// Add these CSS styles for the modal to the document
function addModalStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        .modal-content {
            background-color: #2d2d2d;
            border-radius: 4px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #3e3e3e;
            font-size: 16px;
            font-weight: 500;
        }
        
        .modal-body {
            padding: 15px;
        }
        
        .modal-footer {
            padding: 10px 15px;
            border-top: 1px solid #3e3e3e;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .form-group input {
            width: 100%;
            padding: 8px 10px;
            background-color: #3a3a3a;
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #0078d7;
        }
    `;
    document.head.appendChild(styleElement);
}

// Call this function when initializing the import functionality
function initializeImport() {
    const importButton = document.getElementById('import-button');
    const importDropdown = document.getElementById('import-dropdown');
    
    // If import button doesn't exist, don't continue
    if (!importButton || !importDropdown) {
        return;
    }
    
    const importLocal = document.getElementById('import-local');
    const importUrl = document.getElementById('import-url');
    const importCloud = document.getElementById('import-cloud');
    const createNewScript = document.getElementById('create-new-script');
    
    // Add modal styles
    addModalStyles();
    
    // Create file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'file-input';
    fileInput.accept = '.js,.user.js,.txt';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);
    
    // Create URL import modal
    createUrlImportModal();
    
    // Toggle dropdown when clicking the import button
    importButton.addEventListener('click', (e) => {
        e.stopPropagation();
        importDropdown.classList.toggle('show');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', () => {
        importDropdown.classList.remove('show');
    });
    
    // Prevent dropdown from closing when clicking inside it
    importDropdown.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    // Handle new script creation if the element exists
    if (createNewScript) {
        createNewScript.addEventListener('click', () => {
            // If we're already on a new script page, just reset the content
            if (!scriptId) {
                const scriptContent = document.getElementById('script-content');
                scriptContent.value = getScriptTemplate();
                updateLineNumbers();
                highlightSyntax();
                showStatusMessage('New script template loaded');
            } else {
                // Navigate to a new script page
                window.location.href = 'editor.html';
            }
            importDropdown.classList.remove('show');
        });
    }
    
    // Handle local file import if the element exists
    if (importLocal) {
        importLocal.addEventListener('click', () => {
            // Create a new FileReader instance once
            const reader = new FileReader();
            const scriptContent = document.getElementById('script-content');
            
            // Pre-configure FileReader callbacks
            reader.onload = (event) => {
                scriptContent.value = event.target.result;
                requestAnimationFrame(() => {
                    updateLineNumbers();
                    highlightSyntax();
                });
            };

            // Use input element directly without template
            fileInput.accept = '.js,.user.js,.txt';
            fileInput.click();
            importDropdown.classList.remove('show');
        });
    }
    
    // Handle file selection
    fileInput.addEventListener('change', handleFileImport);
    
    // Handle URL import if the element exists
    if (importUrl) {
        importUrl.addEventListener('click', () => {
            showUrlImportModal();
            importDropdown.classList.remove('show');
        });
    }
    
    // Handle cloud import if the element exists
    if (importCloud) {
        importCloud.addEventListener('click', () => {
            handleCloudImport();
            importDropdown.classList.remove('show');
        });
    }
}

// Create URL import modal
function createUrlImportModal() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'url-modal';
    
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">Import Script from URL</div>
            <div class="modal-body">
                <div class="form-group">
                    <p>Please make sure the URL is a direct link to the raw file. Example: <code>https://github.com/wazerstar/YouTubePremiumFree/blob/main/YouTube-Premium-Free.user.js?raw=True</code></p>
                    <br>
                    <label for="script-url">Script URL</label>
                    <input type="url" id="script-url" placeholder="https://example.com/script.js">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="cancel-url-import">Cancel</button>
                <button class="btn primary" id="confirm-url-import">Import</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add event listeners
    document.getElementById('cancel-url-import').addEventListener('click', () => {
        hideUrlImportModal();
    });
    
    document.getElementById('confirm-url-import').addEventListener('click', () => {
        const url = document.getElementById('script-url').value.trim();
        if (url) {
            importScriptFromUrl(url);
            hideUrlImportModal();
        }
    });
    
    // Close modal when clicking outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideUrlImportModal();
        }
    });
}

// Show URL import modal
function showUrlImportModal() {
    const modal = document.getElementById('url-modal');
    modal.classList.add('show');
    document.getElementById('script-url').value = '';
    document.getElementById('script-url').focus();
}

// Hide URL import modal
function hideUrlImportModal() {
    const modal = document.getElementById('url-modal');
    modal.classList.remove('show');
}

// Handle file import
function handleFileImport(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(event) {
        const content = event.target.result;
        loadImportedScript(content, file.name);
    };
    reader.readAsText(file);
    
    // Reset file input
    e.target.value = '';
}

// Import script from URL
function importScriptFromUrl(url) {
    showStatusMessage('Fetching script from URL...', false);
    
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.text();
        })
        .then(content => {
            const filename = url.split('/').pop() || 'script.js';
            loadImportedScript(content, filename);
        })
        .catch(error => {
            console.error('Error fetching script:', error);
            showStatusMessage(`Error fetching script: ${error.message}`, true);
        });
}

// Handle cloud import
function handleCloudImport() {
    // This would typically integrate with cloud provider APIs
    // For now, we'll show a message about the feature being in development
    showStatusMessage('Cloud import feature coming soon!', false);
    
    // In a real implementation, you would:
    // 1. Authenticate with the cloud provider
    // 2. Show a file picker UI
    // 3. Download the selected file
    // 4. Load the script content
}

// Load imported script content
function loadImportedScript(content, filename) {
    // Set the content in the editor
    const scriptContent = document.getElementById('script-content');
    scriptContent.value = content;
    
    // Update the script title if it's a new script
    if (!scriptId) {
        const scriptTitle = document.getElementById('script-title');
        const cleanName = filename.replace(/\.(js|user\.js|txt)$/, '');
        scriptTitle.textContent = cleanName;
    }
    
    // Update line numbers and syntax highlighting
    updateLineNumbers();
    highlightSyntax();
    
    showStatusMessage(`Script "${filename}" imported successfully`, false);
}

document.getElementById("script-title").textContent = scriptName;

document.addEventListener("DOMContentLoaded", () => {
    initializeEditor();
    loadTempContentIfNeeded();
    initializeImport();
});


